section 1
2.12

2.34

3.48


4.04







  1. Model Classes - Collection, Product, Customer, Order
  2. Field Types
    - CharField
    - TextField
    - DecimalField
    - IntegerField
    - DateTimeField
    - EmailField
    - DateField
  3. Relationships
    - ForeignKey
    - related_name
    - on_delete (SET_NULL, PROTECT)
  4. Magic Methods
    - __str__() - String representation
    - __repr__() - Developer representation
  5. Property Decorator - @property (computed fields)
  6. Meta Class
    - ordering
    - verbose_name
    - verbose_name_plural
    - indexes
  7. Choices - Field choices (MEMBERSHIP_CHOICES)
  8. Field Constraints - unique, null, default, max_length, max_digits,
  decimal_places
  9. Auto Fields - auto_now, auto_now_add

  store/admin.py - Django Admin

  1. Admin Registration
    - @admin.register() decorator
    - admin.site.register()
  2. ModelAdmin Class
  3. List Display Options
    - list_display
    - list_editable
    - list_per_page
  4. Query Optimization
    - list_select_related
  5. Search & Filter
    - search_fields
  6. Custom Admin Methods
    - @admin.display() decorator
  7. QuerySet Customization
    - get_queryset() override
  8. super() Method - Calling parent class methods
  9. Aggregation in Admin - annotate() with Count()

  playground/views.py - Django ORM & Queries

  1. Basic QuerySet Methods
    - all()
    - filter()
    - get()
    - exclude()
    - order_by()
    - reverse()
    - count()
    - exists()
    - first()
    - last()
    - slicing [start:end]
  2. Q Objects - Complex queries
    - OR operator (|)
    - AND operator (&)
    - NOT operator (~)
  3. F Objects - Field references
    - Field comparisons
    - Field arithmetic
  4. Field Lookups
    - __gt, __gte, __lt, __lte
    - __exact, __iexact
    - __contains, __icontains
    - __startswith, __endswith
    - __range
    - __in
    - __isnull
  5. Aggregation Functions
    - Count()
    - Sum()
    - Avg()
    - Max()
    - Min()
    - aggregate()
  6. Annotation
    - annotate()
    - ExpressionWrapper
    - Value()
    - Concat()
  7. Values & Values List
    - values()
    - values_list()
    - flat=True
  8. Query Optimization
    - select_related (ForeignKey, OneToOne - SQL JOIN)
    - prefetch_related (ManyToMany, Reverse FK - Separate queries)
    - only()
    - defer()
    - N+1 query problem
  9. CRUD Operations
    - Create (create(), save(), bulk_create())
    - Read (get(), filter(), all())
    - Update (save(), update())
    - Delete (delete())
  10. Advanced Create/Update
    - get_or_create()
    - update_or_create()
  11. Transactions
    - transaction.atomic() decorator
    - transaction.atomic() context manager
    - Savepoints
    - select_for_update() - Row locking
  12. Other QuerySet Methods
    - distinct()
    - union()

  storefront/urls.py - URL Configuration

  1. URL Patterns - urlpatterns list
  2. path() Function - URL routing
  3. Admin Customization
    - site_header
    - site_title
    - index_title
  4. URL Routing - Connecting URLs to views

  ---
  Summary of Major Topic Categories:

  1. Models - Structure, fields, relationships
  2. Magic Methods - __str__, __repr__
  3. Properties - @property decorator
  4. Meta Class - Model metadata and configuration
  5. Admin - Customization and optimization
  6. QuerySets - Database queries
  7. Q & F Objects - Complex queries and field operations
  8. Lookups - Field query operators
  9. Aggregation - Count, Sum, Avg, etc.
  10. Annotation - Adding computed fields
  11. Optimization - select_related, prefetch_related
  12. CRUD - Create, Read, Update, Delete
  13. Transactions - Atomic operations
  14. URL Routing - Path configuration

================================================================================
 ORM & QUERIES
================================================================================

1.  QUERYSETS 
---------------------
QuerySets are lazy - they don't hit the database until you actually need the data.
This allows you to chain multiple filters and operations efficiently.

Example:
  products = Product.objects.all()  # No database query yet!
  products = products.filter(price__gt=100)  # Still no query!
  products = products.order_by('title')  # Still no query!

  # Query executes NOW when you iterate:
  for product in products:
      print(product.title)

  # Or when you use: list(), count(), len(), [0], .first(), etc.

Key Concept: Django builds a SQL query behind the scenes and only executes
it when you actually need the results.


2.  BASIC QUERYSET METHODS 
-----------------------------------

all() - Returns all objects from database
  Product.objects.all()
  SQL: SELECT * FROM store_product

filter() - Returns objects matching conditions (returns QuerySet)
  Product.objects.filter(price__gt=100)
  SQL: SELECT * FROM store_product WHERE price > 100

get() - Returns single object (raises error if 0 or multiple found)
  Product.objects.get(id=1)
  SQL: SELECT * FROM store_product WHERE id = 1 LIMIT 1

exclude() - Returns objects NOT matching conditions
  Product.objects.exclude(membership='G')
  SQL: SELECT * FROM store_product WHERE NOT membership = 'G'

order_by() - Sort results
  Product.objects.order_by('price')  # Ascending
  Product.objects.order_by('-price')  # Descending
  SQL: SELECT * FROM store_product ORDER BY price ASC/DESC

count() - Count matching records (executes immediately)
  Product.objects.filter(price__gt=100).count()
  SQL: SELECT COUNT(*) FROM store_product WHERE price > 100

exists() - Check if any records exist (returns True/False)
  Product.objects.filter(price__gt=1000).exists()
  SQL: SELECT 1 FROM store_product WHERE price > 1000 LIMIT 1

first() / last() - Get first/last object
  Product.objects.first()
  SQL: SELECT * FROM store_product ORDER BY id ASC LIMIT 1

Slicing [start:end] - Limit results
  Product.objects.all()[:5]
  SQL: SELECT * FROM store_product LIMIT 5


3.  Q OBJECTS 
---------------------
Q objects allow complex queries with OR, AND, NOT logic.
Regular filter() only does AND operations.

OR Queries (|):
  from django.db.models import Q

  # Get products that are cheap OR expensive
  Product.objects.filter(Q(price__lte=50) | Q(price__gt=100))
  SQL: WHERE price <= 50 OR price > 100

AND Queries (&):
  # Get products that are expensive AND low stock
  Product.objects.filter(Q(price__gt=100) & Q(inventory__lt=20))
  SQL: WHERE price > 100 AND inventory < 20

NOT Queries (~):
  # Get products that are NOT cheap
  Product.objects.filter(~Q(price__lte=50))
  SQL: WHERE NOT price <= 50

Combining:
  # (cheap AND low stock) OR (expensive AND high stock)
  Product.objects.filter(
      (Q(price__lte=50) & Q(inventory__lt=10)) |
      (Q(price__gt=100) & Q(inventory__gt=50))
  )
  SQL: WHERE (price <= 50 AND inventory < 10) OR (price > 100 AND inventory > 50)


4.  F OBJECTS 
---------------------
F objects reference database field values directly in queries.
This allows field-to-field comparisons and arithmetic without loading data into Python.

Field Comparisons:
  from django.db.models import F

  # Get products where inventory equals price
  Product.objects.filter(inventory=F('price'))
  SQL: WHERE inventory = price

Field Arithmetic:
  # Get products where price > inventory * 10
  Product.objects.filter(price__gt=F('inventory') * 10)
  SQL: WHERE price > (inventory * 10)

Why use F objects?
  1. Database does the calculation (faster)
  2. No race conditions (updates happen atomically)
  3. Works on fields you haven't loaded yet

Updating with F:
  # Increase all prices by 10%
  Product.objects.all().update(price=F('price') * 1.1)
  SQL: UPDATE store_product SET price = price * 1.1


5.  FIELD LOOKUPS 
-------------------------
Lookups are filters you add after double underscore (__) in field names.

Comparison Lookups:
  __gt - Greater than
  __gte - Greater than or equal
  __lt - Less than
  __lte - Less than or equal

  Example: Product.objects.filter(price__gte=100)

Exact Match:
  __exact - Exact match (case-sensitive)
  __iexact - Case-insensitive exact match

  Example: Customer.objects.filter(email__iexact='JOHN@GMAIL.COM')

String Lookups:
  __contains - Contains substring (case-sensitive)
  __icontains - Case-insensitive contains
  __startswith - Starts with
  __istartswith - Case-insensitive starts with
  __endswith - Ends with
  __iendswith - Case-insensitive ends with

  Example: Customer.objects.filter(email__icontains='gmail')
  SQL: WHERE email LIKE '%gmail%'

Range & Lists:
  __range - Between two values (inclusive)
  __in - In a list of values

  Example: Product.objects.filter(price__range=(50, 100))
  SQL: WHERE price BETWEEN 50 AND 100

  Example: Customer.objects.filter(membership__in=['G', 'S'])
  SQL: WHERE membership IN ('G', 'S')

Null Checks:
  __isnull - Is null or not null

  Example: Customer.objects.filter(birth_date__isnull=False)
  SQL: WHERE birth_date IS NOT NULL


6.  AGGREGATION WORKS
-------------------------
Aggregation calculates a SINGLE value across multiple records.
It returns a dictionary, not a QuerySet.

from django.db.models import Count, Sum, Avg, Max, Min

Count:
  Product.objects.count()
  Returns: 100 (just the number)

aggregate() - Get calculated values:
  Product.objects.aggregate(total=Sum('price'))
  Returns: {'total': 5000.00}
  SQL: SELECT SUM(price) as total FROM store_product

Multiple aggregations:
  Product.objects.aggregate(
      total=Sum('price'),
      average=Avg('price'),
      max_price=Max('price'),
      min_price=Min('price'),
      count=Count('id')
  )
  Returns: {
      'total': 5000.00,
      'average': 50.00,
      'max_price': 999.99,
      'min_price': 9.99,
      'count': 100
  }

Key Point: aggregate() returns a SINGLE result dictionary for ALL records.


7.  ANNOTATION WORKS
------------------------
annotate() adds calculated fields to EACH object in the QuerySet.
Unlike aggregate(), it returns a QuerySet with new fields.

from django.db.models import Count, F, Value, ExpressionWrapper, DecimalField

Basic Annotation:
  # Add inventory value to each product
  products = Product.objects.annotate(
      inventory_value=F('price') * F('inventory')
  )

  for product in products:
      print(product.inventory_value)  # Access like a regular field

With ExpressionWrapper:
  # When mixing field types, specify output type
  products = Product.objects.annotate(
      inventory_value=ExpressionWrapper(
          F('price') * F('inventory'),
          output_field=DecimalField()
      )
  )

Count Related Objects:
  # Add product count to each collection
  collections = Collection.objects.annotate(
      products_count=Count('products')
  )

  for collection in collections:
      print(f"{collection.title}: {collection.products_count} products")

  SQL: SELECT collection.*, COUNT(product.id) as products_count
       FROM collection LEFT JOIN product ON ...
       GROUP BY collection.id

Adding Static Values:
  products = Product.objects.annotate(
      discount_percent=Value(10),
      currency=Value('USD')
  )

String Concatenation:
  from django.db.models.functions import Concat

  customers = Customer.objects.annotate(
      full_name=Concat('first_name', Value(' '), 'last_name')
  )

Key Differences:
  aggregate() → Single value for ALL records (dictionary)
  annotate() → New field for EACH record (QuerySet)


8.  VALUES & VALUES_LIST 
---------------------------------
Instead of returning model objects, return dictionaries or tuples.
This is more efficient when you only need specific fields.

values() - Returns dictionaries:
  products = Product.objects.values('title', 'price')
  Returns: [
      {'title': 'Laptop', 'price': 999.99},
      {'title': 'Mouse', 'price': 29.99},
  ]

  # Access like dict
  for product in products:
      print(product['title'], product['price'])

values_list() - Returns tuples:
  products = Product.objects.values_list('title', 'price')
  Returns: [
      ('Laptop', 999.99),
      ('Mouse', 29.99),
  ]

  # Access by index
  for title, price in products:
      print(title, price)

flat=True - Single field as flat list:
  prices = Product.objects.values_list('price', flat=True)
  Returns: [999.99, 29.99, 49.99, ...]

  # Only works with single field!

When to use:
  - values() when you need multiple fields as dicts
  - values_list() when you need tuples or flat list
  - Regular QuerySet when you need full model functionality


9.  QUERY OPTIMIZATION WORKS
--------------------------------

THE N+1 QUERY PROBLEM:
Without optimization, accessing related objects causes extra queries:

  products = Product.objects.all()  # 1 query
  for product in products:
      print(product.collection.title)  # 1 query PER product!

  Total: 1 + N queries (if 100 products = 101 queries!)

select_related() - For ForeignKey & OneToOneField:
  Uses SQL JOIN to fetch related data in SINGLE query.

  products = Product.objects.select_related('collection')  # 1 query with JOIN
  for product in products:
      print(product.collection.title)  # NO extra queries!

  SQL: SELECT * FROM product JOIN collection ON product.collection_id = collection.id

  When to use: Forward ForeignKey (product.collection)

prefetch_related() - For ManyToMany & Reverse ForeignKey:
  Uses separate queries but optimizes with IN clause.

  customers = Customer.objects.prefetch_related('orders')  # 2 queries
  for customer in customers:
      for order in customer.orders.all():  # NO extra queries!
          print(order.placed_at)

  Query 1: SELECT * FROM customer
  Query 2: SELECT * FROM order WHERE customer_id IN (1, 2, 3, ...)

  When to use: Reverse relationships (customer.orders) or ManyToMany

only() - Load only specific fields:
  products = Product.objects.only('title', 'price')
  # Only fetches title and price, other fields loaded on access

defer() - Load all fields EXCEPT specified:
  products = Product.objects.defer('description')
  # Loads everything except description


10.  CRUD OPERATIONS 
-----------------------------

CREATE:
  Method 1: create() - Create and save in one step
    product = Product.objects.create(
        title='Laptop',
        price=999.99,
        inventory=50
    )

  Method 2: Instantiate then save()
    product = Product(title='Laptop', price=999.99)
    product.save()

  Method 3: bulk_create() - Multiple objects at once
    Product.objects.bulk_create([
        Product(title='Mouse', price=29.99),
        Product(title='Keyboard', price=79.99),
    ])
    # Much faster! Single INSERT with multiple values

READ:
  get() - Single object (raises error if not found or multiple)
    product = Product.objects.get(id=1)

  filter() - Multiple objects
    products = Product.objects.filter(price__gt=100)

  all() - All objects
    products = Product.objects.all()

UPDATE:
  Method 1: Get, modify, save
    product = Product.objects.get(id=1)
    product.price = 899.99
    product.save()

  Method 2: update() - Bulk update (more efficient)
    Product.objects.filter(collection__title='Electronics').update(
        price=F('price') * 1.1
    )
    # Updates all matching records in single query

DELETE:
  Method 1: Get, then delete
    product = Product.objects.get(id=1)
    product.delete()

  Method 2: Filter, then delete
    Product.objects.filter(inventory=0).delete()
    # Deletes all matching records

get_or_create() - Get existing or create new:
  collection, created = Collection.objects.get_or_create(
      title='Gaming',
      defaults={'featured_product': None}
  )
  # created = True if new, False if existing

update_or_create() - Update if exists, create if not:
  product, created = Product.objects.update_or_create(
      title='Gaming Mouse',
      defaults={
          'price': 49.99,
          'inventory': 100
      }
  )


11.  TRANSACTIONS 
--------------------------
Transactions ensure multiple database operations either ALL succeed or ALL fail.
This prevents partial/inconsistent data updates.

Why use transactions?
  Scenario: Creating order and deducting inventory
    1. Create order
    2. Deduct product inventory

  Problem: If step 2 fails, you have an order but inventory wasn't updated!
  Solution: Use transaction - both succeed or both fail.

Method 1: @transaction.atomic decorator
  from django.db import transaction

  @transaction.atomic
  def create_order():
      order = Order.objects.create(customer=customer)
      product.inventory -= 1
      product.save()
      # If ANY error occurs, EVERYTHING is rolled back

Method 2: with transaction.atomic() context manager
  with transaction.atomic():
      collection = Collection.objects.create(title='Test')
      Product.objects.create(title='Product 1', collection=collection)
      Product.objects.create(title='Product 2', collection=collection)
      # If error, collection and both products NOT saved

Savepoints - Partial rollback:
  with transaction.atomic():
      customer = Customer.objects.create(...)  # Will be saved

      sid = transaction.savepoint()

      try:
          order = Order.objects.create(customer=customer)
      except:
          transaction.savepoint_rollback(sid)  # Only rollback order, keep customer
      else:
          transaction.savepoint_commit(sid)

Row Locking - select_for_update():
  Prevents race conditions by locking rows until transaction completes.

  with transaction.atomic():
      product = Product.objects.select_for_update().get(id=1)
      product.inventory -= 1
      product.save()
      # Other transactions must WAIT until this completes

When to use transactions:
  1. Creating related objects (Order + OrderItems)
  2. Transferring resources (inventory, money)
  3. Any operation where partial completion = bad data


12.  OTHER QUERYSET METHODS 
------------------------------------

distinct() - Remove duplicate results:
  prices = Product.objects.values_list('price', flat=True).distinct()
  SQL: SELECT DISTINCT price FROM product

union() - Combine two querysets:
  expensive = Product.objects.filter(price__gt=100)
  low_stock = Product.objects.filter(inventory__lt=10)
  combined = expensive.union(low_stock)
  # Returns products that are EITHER expensive OR low stock (no duplicates)

reverse() - Reverse ordering:
  products = Product.objects.order_by('price').reverse()
  # Same as order_by('-price')

latest() / earliest() - Get by date field:
  product = Product.objects.latest('last_update')
  # Gets most recently updated product


================================================================================
 MODELS
================================================================================

1.  MODELS 
------------------
Models are Python classes that represent database tables.
Each model class = 1 database table
Each model attribute = 1 database column

Example from your code:
  class Product(models.Model):
      title = models.CharField(max_length=255)
      price = models.DecimalField(max_digits=10, decimal_places=2)
      inventory = models.IntegerField()

This creates a database table:
  Table name: store_product
  Columns: id (auto-created), title, price, inventory

Django automatically:
  - Creates an 'id' field as primary key
  - Handles table creation with migrations
  - Provides query methods (objects.all(), filter(), etc.)


2.  FIELD TYPES 
-----------------------
Field types define what kind of data each column stores.

CharField - Short text (requires max_length)
  title = models.CharField(max_length=255)
  Database: VARCHAR(255)
  Use for: Names, titles, short strings

TextField - Long text (no length limit)
  description = models.TextField()
  Database: TEXT
  Use for: Descriptions, blog posts, comments

DecimalField - Decimal numbers (requires max_digits, decimal_places)
  price = models.DecimalField(max_digits=10, decimal_places=2)
  Database: DECIMAL(10, 2)
  Use for: Money, precise calculations
  Example: 999999.99

IntegerField - Whole numbers
  inventory = models.IntegerField()
  Database: INTEGER
  Use for: Counts, quantities, ages

DateTimeField - Date and time
  last_update = models.DateTimeField(auto_now=True)
  Database: TIMESTAMP
  Use for: Created/updated timestamps

DateField - Date only (no time)
  birth_date = models.DateField(null=True)
  Database: DATE
  Use for: Birthdays, due dates

EmailField - Email addresses (validates format)
  email = models.EmailField(unique=True)
  Database: VARCHAR(254)
  Use for: Email addresses (auto-validates format)

BooleanField - True/False
  is_active = models.BooleanField(default=True)
  Database: BOOLEAN
  Use for: Flags, yes/no values

URLField - URLs (validates format)
  website = models.URLField()
  Database: VARCHAR(200)
  Use for: Website links

SlugField - URL-friendly strings (lowercase, hyphens)
  slug = models.SlugField()
  Database: VARCHAR(50)
  Use for: URL slugs (e.g., "my-blog-post")

JSONField - JSON data
  metadata = models.JSONField()
  Database: JSON
  Use for: Flexible structured data

FileField - File uploads
  document = models.FileField(upload_to='documents/')
  Use for: Any file uploads

ImageField - Image uploads (validates image format)
  photo = models.ImageField(upload_to='photos/')
  Use for: Photos, images

AutoField - Auto-incrementing integer (Django creates this as 'id' automatically)
  id = models.AutoField(primary_key=True)
  Database: INTEGER with AUTO_INCREMENT


3.  RELATIONSHIPS 
--------------------------
Relationships connect models together, just like database foreign keys.

ForeignKey - Many-to-One relationship
  "Many products belong to ONE collection"

  class Product(models.Model):
      collection = models.ForeignKey(
          Collection,
          on_delete=models.PROTECT,
          related_name='products'
      )

  Forward access (product → collection):
    product = Product.objects.get(id=1)
    print(product.collection.title)  # Access collection

  Reverse access (collection → products):
    collection = Collection.objects.get(id=1)
    print(collection.products.all())  # Access all products in collection
    # 'products' comes from related_name='products'

on_delete options:
  models.CASCADE - Delete related objects (delete collection = delete all its products)
  models.PROTECT - Prevent deletion (can't delete collection if it has products)
  models.SET_NULL - Set to NULL (delete collection = set product.collection to NULL)
  models.SET_DEFAULT - Set to default value

related_name:
  related_name='products' → Access from collection: collection.products.all()
  related_name='+' → No reverse relation (can't access from parent)

OneToOneField - One-to-One relationship
  "One user has ONE profile"

  class UserProfile(models.Model):
      user = models.OneToOneField(User, on_delete=models.CASCADE)

ManyToManyField - Many-to-Many relationship
  "Many students in many courses"

  class Student(models.Model):
      courses = models.ManyToManyField(Course)

  student.courses.all()  # All courses for student
  course.student_set.all()  # All students in course


4.  MAGIC METHODS 
--------------------------
Magic methods define how objects are displayed and represented.

__str__() - String representation (for humans)
  Used in: Admin, templates, print statements

  def __str__(self):
      return self.title

  Example:
    product = Product.objects.get(id=1)
    print(product)  # Output: "Laptop" (instead of "<Product object (1)>")

  In Django admin: Shows "Laptop" in dropdowns and lists

__repr__() - Developer representation (for debugging)
  Used in: Python shell, debugging, logs

  def __repr__(self):
      return f"<Product(id={self.pk}, title='{self.title}', price={self.price})>"

  Example:
    product = Product.objects.get(id=1)
    repr(product)  # Output: "<Product(id=1, title='Laptop', price=999.99)>"

Difference:
  __str__() → User-friendly display
  __repr__() → Developer-friendly debug info


5.  PROPERTY DECORATOR WORKS
--------------------------------
@property converts a method into a read-only attribute (computed field).
The field is calculated on-the-fly, NOT stored in database.

Without @property (regular method):
  class Product(models.Model):
      inventory = models.IntegerField()

      def is_low_stock(self):
          return self.inventory < 10

  # Usage: Need parentheses
  if product.is_low_stock():  # Method call
      print("Low stock!")

With @property:
  class Product(models.Model):
      inventory = models.IntegerField()

      @property
      def is_low_stock(self):
          return self.inventory < 10

  # Usage: Access like attribute (no parentheses)
  if product.is_low_stock:  # Property access
      print("Low stock!")

Benefits:
  1. Cleaner syntax (no parentheses)
  2. Works in Django templates: {{ product.is_low_stock }}
  3. Reads like an attribute, not an action
  4. Computed on-the-fly (always current)

Examples from your code:
  @property
  def full_name(self):
      return f"{self.first_name} {self.last_name}"

  # Usage
  customer.full_name  # "John Doe"

  @property
  def is_in_stock(self):
      return self.inventory > 0

  # Usage
  if product.is_in_stock:
      print("Available!")

When to use @property:
  ✅ Computed values (full_name, age, price_with_tax)
  ✅ Boolean checks (is_active, is_valid, is_low_stock)
  ✅ Formatted data (display_date, formatted_price)
  ❌ Don't use for heavy database queries
  ❌ Don't use for actions with side effects (save, delete, send_email)


6.  META CLASS WORKS
------------------------
Meta class provides metadata and configuration for the model.
It controls model behavior, NOT database fields.

class Meta:
    # Configuration goes here

ordering - Default sort order for queries
  class Meta:
      ordering = ['title']  # A-Z by title
      ordering = ['-price']  # Highest price first
      ordering = ['last_name', 'first_name']  # Sort by multiple fields

  Effect:
    Product.objects.all()  # Automatically sorted by title
    Customer.objects.all()  # Automatically sorted by last_name, then first_name

verbose_name - Human-readable singular name
  class Meta:
      verbose_name = 'Product'

  Shows in: Django admin ("Add Product", "Delete Product")

verbose_name_plural - Human-readable plural name
  class Meta:
      verbose_name_plural = 'Products'

  Without this: "Products" → "Products" ✅
  Without this: "Category" → "Categorys" ❌
  With this: "Category" → "Categories" ✅

indexes - Database indexes (speed up queries)
  class Meta:
      indexes = [
          models.Index(fields=['title']),
          models.Index(fields=['email']),
      ]

  Effect: Searching by title or email becomes much faster
  SQL: CREATE INDEX ON store_product(title)

db_table - Custom table name
  class Meta:
      db_table = 'my_custom_products'

  Default: app_modelname (e.g., store_product)
  Custom: my_custom_products

unique_together - Multiple fields must be unique together
  class Meta:
      unique_together = [['first_name', 'last_name']]

  Prevents duplicate combinations (e.g., two "John Smith" entries)

abstract - Make model abstract (no database table)
  class Meta:
      abstract = True

  Used for: Base models that other models inherit from

permissions - Custom permissions
  class Meta:
      permissions = [
          ('can_approve', 'Can approve products'),
          ('can_publish', 'Can publish articles'),
      ]

Example from your code:
  class Meta:
      ordering = ['title']  # Always sorted alphabetically
      verbose_name = 'Product'  # Shown in admin
      verbose_name_plural = 'Products'  # Shown in admin
      indexes = [models.Index(fields=['title'])]  # Fast title searches


7.  CHOICES 
-------------------
Choices restrict field values to a predefined list (like a dropdown).

Define choices as list of tuples:
  (database_value, human_readable_name)

Example 
  MEMBERSHIP_BRONZE = 'B'
  MEMBERSHIP_SILVER = 'S'
  MEMBERSHIP_GOLD = 'G'

  MEMBERSHIP_CHOICES = [
      (MEMBERSHIP_BRONZE, 'Bronze'),  # Stores 'B', displays 'Bronze'
      (MEMBERSHIP_SILVER, 'Silver'),  # Stores 'S', displays 'Silver'
      (MEMBERSHIP_GOLD, 'Gold'),      # Stores 'G', displays 'Gold'
  ]

  membership = models.CharField(
      max_length=1,
      choices=MEMBERSHIP_CHOICES,
      default=MEMBERSHIP_BRONZE
  )

In database: Stores 'B', 'S', or 'G'
In admin: Shows dropdown with "Bronze", "Silver", "Gold"

Access values:
  customer.membership  # 'G' (database value)
  customer.get_membership_display()  # 'Gold' (human-readable)

Benefits:
  1. Prevents invalid values (only B/S/G allowed)
  2. Cleaner code (use constants instead of magic strings)
  3. Admin shows dropdown automatically
  4. Easy to change display names without changing data


8.  FIELD CONSTRAINTS 
------------------------------
Constraints add validation and rules to fields.

unique - Field value must be unique
  email = models.EmailField(unique=True)
  # No two customers can have same email

null - Allow NULL in database
  birth_date = models.DateField(null=True)
  # birth_date can be empty in database

blank - Allow empty in forms/admin
  description = models.TextField(blank=True)
  # Can submit form without description

null vs blank:
  null=True → Database allows NULL
  blank=True → Forms/admin allow empty
  Usually use both together: null=True, blank=True

default - Default value if not provided
  membership = models.CharField(default='B')
  inventory = models.IntegerField(default=0)

max_length - Maximum string length (required for CharField)
  title = models.CharField(max_length=255)
  # Max 255 characters

max_digits - Maximum total digits (DecimalField)
  price = models.DecimalField(max_digits=10, decimal_places=2)
  # Max 10 digits total, 2 after decimal (e.g., 99999999.99)

decimal_places - Decimal places (DecimalField)
  price = models.DecimalField(max_digits=10, decimal_places=2)
  # Always 2 decimal places (e.g., 49.99)

validators - Custom validation
  from django.core.validators import MinValueValidator, MaxValueValidator

  age = models.IntegerField(
      validators=[MinValueValidator(0), MaxValueValidator(120)]
  )

editable - Can be edited in forms/admin
  created_at = models.DateTimeField(auto_now_add=True, editable=False)
  # Can't edit in admin


9.  AUTO FIELDS 
------------------------
Auto fields automatically set values based on events.

auto_now - Update to current time on EVERY save
  last_update = models.DateTimeField(auto_now=True)

  When it updates:
    - Every time you call product.save()
    - Every time object is updated

  Use for: "Last modified" timestamps

auto_now_add - Set to current time ONLY on creation
  placed_at = models.DateTimeField(auto_now_add=True)

  When it sets:
    - Only when object is first created
    - Never updates after that

  Use for: "Created at" timestamps

Example:
  class Order(models.Model):
      placed_at = models.DateTimeField(auto_now_add=True)  # Set once
      updated_at = models.DateTimeField(auto_now=True)     # Updates every save

  order = Order.objects.create()
  # placed_at = 2025-01-01 10:00:00
  # updated_at = 2025-01-01 10:00:00

  # ... 5 minutes later ...
  order.save()
  # placed_at = 2025-01-01 10:00:00 (unchanged)
  # updated_at = 2025-01-01 10:05:00 (updated!)

Note: These fields are automatically set, you can't manually change them.


================================================================================
 ADMIN
================================================================================

1.  ADMIN REGISTRATION WORKS
--------------------------------
To make models editable in Django admin, you must register them.

Method 1: admin.site.register() - Basic registration
  from django.contrib import admin
  from store.models import Product

  admin.site.register(Product)
  # Product now appears in admin with default settings

Method 2: With ModelAdmin class - Custom configuration
  class ProductAdmin(admin.ModelAdmin):
      list_display = ['id', 'title', 'price']

  admin.site.register(Product, ProductAdmin)
  # Product appears with custom display settings

Method 3: @admin.register() decorator - Cleaner syntax
  @admin.register(Product)
  class ProductAdmin(admin.ModelAdmin):
      list_display = ['id', 'title', 'price']

  # Same as Method 2, but cleaner (decorator does the registration)

Your code uses Method 3 (decorator):
  @admin.register(Customer)
  class CustomerAdmin(admin.ModelAdmin):
      list_display = ('id', 'first_name', 'last_name', 'email')


2.  MODELADMIN CLASS WORKS
------------------------------
ModelAdmin class customizes how models appear and behave in Django admin.

Basic structure:
  @admin.register(Product)
  class ProductAdmin(admin.ModelAdmin):
      # All customizations go here
      list_display = [...]
      list_filter = [...]
      search_fields = [...]

Common customizations:
  - What columns to show (list_display)
  - Which fields can be edited inline (list_editable)
  - How many items per page (list_per_page)
  - Search functionality (search_fields)
  - Filters (list_filter)
  - Query optimization (list_select_related)
  - Custom methods (@admin.display)


3.  LIST DISPLAY OPTIONS 
---------------------------------

list_display - Columns shown in admin list view
  list_display = ('id', 'title', 'price', 'inventory')

  Default: Only shows __str__() value
  With list_display: Shows multiple columns as a table

  Can include:
    - Model fields: 'title', 'price'
    - Related fields: 'collection'
    - Custom methods: 'inventory_status'
    - Properties: defined with @property

list_editable - Edit fields directly in list (without opening detail page)
  list_editable = ['phone']

  User can edit phone numbers directly in the list view
  Must include field in list_display first

list_per_page - Items per page (pagination)
  list_per_page = 5

  Default: 100
  Shows 5 items per page with pagination

list_filter - Add filters in sidebar
  list_filter = ['membership', 'birth_date']

  Adds filter options in right sidebar
  Automatically creates appropriate filter type based on field type

list_select_related - Optimize queries (see next section)

Example from your code:
  @admin.register(Customer)
  class CustomerAdmin(admin.ModelAdmin):
      list_display = ('id', 'first_name', 'last_name', 'email', 'phone', 'membership')
      list_editable = ['phone']  # Edit phone directly in list
      list_per_page = 5  # Show 5 customers per page


4.  QUERY OPTIMIZATION IN ADMIN WORKS
-----------------------------------------

list_select_related - Optimize ForeignKey queries
  Prevents N+1 query problem in admin list view.

  Without list_select_related:
    @admin.register(Product)
    class ProductAdmin(admin.ModelAdmin):
        list_display = ('id', 'title', 'collection')

    Queries:
      1. Get all products (1 query)
      2. For each product, get its collection (N queries)
      Total: 1 + N = 101 queries for 100 products! 😱

  With list_select_related:
    @admin.register(Product)
    class ProductAdmin(admin.ModelAdmin):
        list_display = ('id', 'title', 'collection')
        list_select_related = ['collection']

    Queries:
      1. Get all products with collections (1 query with JOIN)
      Total: 1 query! 🎉

  When to use:
    ✅ ForeignKey fields in list_display
    ✅ OneToOneField fields
    ❌ ManyToManyField (use list_prefetch_related instead)
    ❌ Reverse ForeignKey relationships


5.  SEARCH & FILTER 
----------------------------

search_fields - Add search box
  search_fields = ['title']

  Adds search box at top of admin list
  Searches in specified fields

  Example:
    search_fields = ['title', 'description']
    # Searches in both title and description

  Search operators:
    search_fields = ['^title']  # Starts with (^)
    search_fields = ['=email']  # Exact match (=)
    search_fields = ['@description']  # Full-text search (@)

list_filter - Add filter sidebar
  list_filter = ['membership', 'birth_date']

  Adds filters in right sidebar
  Django automatically creates appropriate filter based on field type:
    - CharField with choices → Dropdown
    - DateField → Date range
    - BooleanField → Yes/No
    - ForeignKey → Related objects

Your code example:
  @admin.register(Collection)
  class CollectionAdmin(admin.ModelAdmin):
      search_fields = ['title']  # Search collections by title


6.  CUSTOM ADMIN METHODS 
---------------------------------
Add computed fields to admin list view using custom methods.

Basic custom method:
  @admin.register(Product)
  class ProductAdmin(admin.ModelAdmin):
      list_display = ('id', 'title', 'inventory_status')

      def inventory_status(self, product):
          if product.inventory < 60:
              return 'Low'
          return 'OK'

  'inventory_status' appears as a column in admin

@admin.display() decorator - Add options to custom methods
  @admin.display(ordering='inventory')
  def inventory_status(self, product):
      if product.inventory < 60:
          return 'Low'
      return 'OK'

  ordering='inventory' → Makes column sortable by inventory field

Other @admin.display() options:
  @admin.display(description='Stock Status')  # Custom column header
  def inventory_status(self, product):
      ...

  @admin.display(boolean=True)  # Shows as icon (✓ or ✗)
  def is_available(self, product):
      return product.inventory > 0

Your code example:
  @admin.display(ordering='inventory')
  def inventory_status(self, product):
      if product.inventory < 60:
          return 'Low'
      return 'OK'


7.  QUERYSET CUSTOMIZATION WORKS
------------------------------------
Override get_queryset() to customize the queryset used in admin.

Default behavior:
  Django uses: ModelName.objects.all()

Custom behavior:
  Override get_queryset() to add filters, annotations, optimizations

  def get_queryset(self, request):
      return super().get_queryset(request).annotate(
          products_count=Count('products')
      )

Your code example:
  @admin.register(Collection)
  class CollectionAdmin(admin.ModelAdmin):
      list_display = ('id', 'title', 'product_count')

      def get_queryset(self, request):
          return super().get_queryset(request).annotate(
              products_count=Count('products')
          )

      @admin.display(ordering='products_count')
      def product_count(self, collection):
          return collection.products_count

How it works:
  1. get_queryset() adds products_count annotation to EVERY collection
  2. product_count() method accesses the annotated field
  3. No extra queries! Count is already calculated

Why annotate in get_queryset()?
  - Calculated once for all objects (efficient)
  - Can sort by the annotated field
  - Prevents N+1 queries


8.  SUPER() METHOD WORKS
----------------------------
super() calls the parent class's method, allowing you to extend (not replace) functionality.

Without super() - Replaces parent completely:
  def get_queryset(self, request):
      return Collection.objects.annotate(...)  # ❌ Loses Django admin features!

With super() - Extends parent functionality:
  def get_queryset(self, request):
      return super().get_queryset(request).annotate(...)  # ✅ Keeps admin features!

Why use super()?
  1. Keeps Django's built-in functionality (permissions, filters, search)
  2. Adds your customizations on top
  3. Safe - won't break if Django updates

Example:
  def get_queryset(self, request):
      # Get Django's default queryset (includes permissions, filters, etc.)
      qs = super().get_queryset(request)

      # Add your customizations
      qs = qs.annotate(products_count=Count('products'))

      # Return enhanced queryset
      return qs

Analogy: Building on a foundation
  - Without super(): Tear down house and rebuild from scratch
  - With super(): Start with existing house and add renovations


9.  AGGREGATION IN ADMIN WORKS
----------------------------------
Show aggregated data (counts, sums, averages) in admin list.

Problem: Displaying count of related objects
  Show how many products are in each collection

Bad solution (N+1 queries):
  def product_count(self, collection):
      return collection.products.count()  # Separate query for EACH collection!

Good solution (single query with annotation):
  def get_queryset(self, request):
      return super().get_queryset(request).annotate(
          products_count=Count('products')
      )

  @admin.display(ordering='products_count')
  def product_count(self, collection):
      return collection.products_count  # Already calculated!

Complete example from your code:
  @admin.register(Collection)
  class CollectionAdmin(admin.ModelAdmin):
      list_display = ('id', 'title', 'featured_product', 'product_count')

      def get_queryset(self, request):
          # Add products_count to every collection
          return super().get_queryset(request).annotate(
              products_count=Count('products')
          )

      @admin.display(ordering='products_count')
      def product_count(self, collection):
          # Access the annotated field
          return collection.products_count

How it works:
  1. get_queryset() runs ONCE for all collections
  2. Adds products_count annotation using SQL GROUP BY
  3. product_count() displays the pre-calculated value
  4. ordering='products_count' allows sorting by count
  5. Total: 1 query for all data!

Other aggregations in admin:
  # Total inventory value per collection
  .annotate(total_value=Sum('products__price'))

  # Average product price per collection
  .annotate(avg_price=Avg('products__price'))

  # Most expensive product in collection
  .annotate(max_price=Max('products__price'))